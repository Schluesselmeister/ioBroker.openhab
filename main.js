/**
 *
 * openhab adapter Copyright 2017, bluefox <dogafox@gmail.com>
 *
 */

/* jshint -W097 */
/* jshint strict:false */
/* jslint node: true */
'use strict';

// you have to require the utils module and call adapter function
var utils       = require(__dirname + '/lib/utils'); // Get common adapter utils
var request     = require('request');
var adapter     = new utils.Adapter('openhab');
var ohTypes     = require(__dirname + '/lib/types.js');
var rooms       = require(__dirname + '/lib/rooms.js');
var funcs       = require(__dirname + '/lib/functions.js');
var EventSource = require('eventsource');
var client;
var objects = {};
var states  = [];
var connected = false;
var connectingTimeout = null;
var URL;
var es;
var secret =     'Zgfr56gFe87jJOM'; // Will be generated by first start

// is called when adapter shuts down - callback has to be called under any circumstances!
adapter.on('unload', function (callback) {
    try {
        if (adapter.setState) adapter.setState('info.connection', false, true);
        if (client) client.disconnect();
        client = null;
        adapter.log.info('cleaned everything up...');
        callback();
    } catch (e) {
        callback();
    }
});

function oh2iob(type, val) {

    if (undefined === type) {
        type = 'undefined';
    }

    type = type.toLowerCase(); // get rid of capital letters. Makes it easy to parse.

    if (type === 'booleantype' || type === 'boolean') {
        return (val === true || val === 'true' || val === '1' || val === 1 || val === 'on' || val === 'ON')
    } else if (type === 'decimaltype' || type === 'decimal' || type === 'number' || type === 'dimmer' || type === 'rollershutter') {
        return parseFloat((val || '0').toString().replace(',', '.'));
    } else if (type === 'onofftype' || type === 'onoff' || type === 'switch') {
        return (val === 'ON' || val === 'on');
    } else if (type === 'openclosedtype' || type === 'openclosed' || type === 'contact') {
        return (val === 'OPEN' || val === 'open');
    }  else if (type === 'percenttype' || type === 'percent') {
        return parseFloat(val);
    } else if (type === 'stringtype' || type === 'string' || type === 'location') {
        // only workaround for Openhab window handle (tri state)
        if (val === 'OPEN') {
            return 'open';
        } else if (val === 'CLOSED') {
            return 'closed';
        } else if (val === 'AJAR') {
            return 'tilt';
        } else {
            return val;
        }
    } else if (type === 'datetimetype' || type === 'datetime') {
        // do nothing
        // 2017-05-05T03:28:00.000+0000
        return val;
    } else if (type === 'hsbtype' || type === 'hsb') {
        // do nothing
        // 336,17,37
        return val;
    } else {
        adapter.log.warn('oh2iob - Unknown type: ' + type);
        return val;
    }
}


function iob2oh(type, val)
{
    if (undefined === type) {
        type = 'undefined';
    }

    type = type.toLowerCase(); // get rid of capital letters. Makes it easy to parse.

    if (type === 'switch') {
        if (val === true || val === 'true' || val === 1 || val === '1' || val === 'ON' || val === 'on') {
            return 'ON'; 
        } else {
            return 'OFF';
        }
    } else if (type === 'number') {
        return parseFloat(val);
    } else if (type === 'dimmer' || type === 'rollershutter') {
        return parseInt(val);
    } else if (type === 'contact') { // not yet supported by Openhab, but maybe in the future
        if (val === true || val === 'true' || val === 1 || val === '1' || val === 'OPEN' || val === 'open') {
            return 'OPEN';
        } else {
            return 'CLOSED';
        }
    } else if (type === 'string') {
        // Writing of window handle is not supported
        return val;
    } else {
        adapter.log.warn('iob2oh - Unknown type: ' + type);
        return val;
    }
}


// is called if a subscribed state changes
adapter.on('stateChange', function (id, state) {
    adapter.log.debug('stateChange ' + id + ' ' + JSON.stringify(state));
    if (state && !state.ack) {
        if (objects[id]) {
            if (objects[id].common.write && objects[id].native.name) {
                states[id] = state.val;
                if (!connected) {
                    adapter.log.warn('Cannot control: no connection to openhab "' + adapter.config.host + '"');
                } else {
                    adapter.log.debug('Type = ' + objects[id].native.type);

                    var originalVal = state.val;

                    if (state.val === null || state.val === undefined) {
                        state.val = '';
                    } else {
                        // convert values
                        state.val = iob2oh(objects[id].native.type, state.val);
                    }

                    var link = URL + '/items/' + objects[id].native.name;
                    adapter.log.debug(link);

                    request.post({
                        headers: {'content-type': 'text/plain'},
                        url: link,
                        body: state.val.toString()
                    }, function (err, res, body) {
                        if (err || res.statusCode !== 200) {
                            adapter.log.warn('Cannot write "' + id + '": ' + (body || err || res.statusCode));
                            adapter.setForeignState(id, {val: originalVal, ack: true, q: 0x40});
                        } else {
                            adapter.setForeignState(id, {val: originalVal, ack: true, q: 0x0});
                        }
                    });
                }
            } else {
                adapter.log.warn('State "' + id + '" is read only');
            }
        } else {
            adapter.log.warn('Unknown state "' + id + '"');
        }
    }
});

// Some message was sent to adapter instance over message box. Used by email, pushover, text2speech, ...
adapter.on('message', function (obj) {
    if (typeof obj === 'object' && obj.message) {
        if (obj.command === 'send') {
            // e.g. send email or pushover or whatever
            console.log('send command');

            // Send response in callback if required
            if (obj.callback) adapter.sendTo(obj.from, obj.command, 'Message received', obj.callback);
        }
    }
});

// is called when databases are connected and adapter received configuration.
// start here!
adapter.on('ready', function () {
    // Generate secret for session manager
    if (adapter.config.username) {
        adapter.getForeignObject('system.config', function (err, obj) {
            if (!err && obj) {
                if (!obj.native || !obj.native.secret) {
                    obj.native = obj.native || {};

                    require('crypto').randomBytes(24, function (ex, buf) {
                        secret = buf.toString('hex');
                        adapter.extendForeignObject('system.config', {native: {secret: secret}});
                        main();
                    });
                } else {
                    adapter.config.password = decrypt(obj.native.secret, new Buffer(adapter.config.password, 'base64').toString('binary'));
                    main();
                }
            } else {
                adapter.logger.error('Cannot find object system.config');
            }
        });
    } else {
        main();
    }

});

function decrypt(key, value) {
    var result = '';
    for (var i = 0; i < value.length; ++i) {
        result += String.fromCharCode(key[i % key.length].charCodeAt(0) ^ value.charCodeAt(i));
    }
    return result;
}


function syncObjects(objs, callback) {
    if (!objs || !objs.length) {
        callback && callback();
        return;
    }
    var obj = objs.shift();
    adapter.getForeignObject(obj._id, function (err, oObj) {
        if (!oObj) {
            objects[obj._id] = obj;
            adapter.setForeignObject(obj._id, obj, function () {
                setTimeout(syncObjects, 0, objs, callback);
            });
        } else {
            var changed = false;
            for (var a in obj.common) {
                if (obj.common.hasOwnProperty(a) && oObj.common[a] !== obj.common[a]) {
                    changed = true;
                    oObj.common[a] = obj.common[a];
                }
            }
            if (JSON.stringify(obj.native) !== JSON.stringify(oObj.native)) {
                changed = true;
                oObj.native = obj.native;
            }
            objects[obj._id] = oObj;
            if (changed) {
                adapter.setForeignObject(oObj._id, oObj, function () {
                    setTimeout(syncObjects, 0, objs, callback);
                });
            } else {
                setTimeout(syncObjects, 0, objs, callback);
            }
        }
    });
}


function syncStates(_states, callback) {
    if (!_states || !_states.length) {
        callback && callback();
        return;
    }
    var state = _states.shift();
    adapter.getForeignState(state._id, function (err, oState) {
        if (!oState) {
            adapter.setForeignState(state._id, state.val, function () {
                setTimeout(syncStates, 0, _states, callback);
            });
        } else {
            var changed = false;
            for (var a in state.val) {
                if (state.val.hasOwnProperty(a) &&
                    (typeof state.val[a] !== 'object' && state.val[a] !== oState[a]) ||
                    (typeof state.val[a] === 'object' && JSON.stringify(state.val[a]) !== JSON.stringify(oState[a]))) {
                    changed = true;
                    oState[a] = state.val[a];
                }
            }
            if (changed) {
                adapter.setForeignState(state._id, oState, function () {
                    setTimeout(syncStates, 0, _states, callback);
                });
            } else {
                setTimeout(syncStates, 0, _states, callback);
            }
        }
    });
}
/*
function syncDevices(devices, callback) {
    var objs = [];
    var _states = [];
    for (var d = 0; d < devices.length; d++) {
        var localObjects = [];
        var device = devices[d];
        var obj = {
            _id: adapter.namespace + '.devices.' + device.id,
            common: {
                name: device.name
            },
            type: 'channel'
        };
        objs.push(obj);
        var attributes = device.attributes;
        if ((!attributes || !attributes.length) && device.config) attributes = device.config.attributes;

        if (attributes && attributes.length) {
            for (var a = 0; a < attributes.length; a++) {
                var attr = attributes[a];
                var id = adapter.namespace + '.devices.' + device.id + '.' + attr.name.replace(/\s/g, '_');
                obj = {
                    _id: id,
                    common: {
                        name: device.name + ' - ' + (attr.acronym || attr.name),
                        desc: attr.description,
                        type: attr.type,
                        read: true,
                        write: false,
                        unit: attr.unit === 'c' ? '°C' : (attr.unit === 'f' ? '°F' : attr.unit)
                        //role: acronym2role(attr.acronym)
                    },
                    native: {

                    },
                    type: 'state'
                };
                _states.push({
                    _id: id,
                    val: {
                        ack: true,
                        val: attr.value,
                        ts:  attr.lastUpdate
                    }
                });
                states[id] = attr.value;
                delete attr.value;
                delete attr.lastUpdate;
                delete attr.history;
                obj.native = attr;

                if (obj.common.type === 'boolean') {
                    if (device.template === 'presence') obj.common.role = 'state';//'indicator.presence';
                    if (attr.labels && attr.labels[0] !== 'true') {
                        obj.common.states = {false: attr.labels[1], true: attr.labels[0]};
                    }
                } else
                if (obj.common.type === 'number') {
                    if (obj.common.unit === '°C' || obj.common.unit === '°F') {
                        obj.common.role = 'value.temperature';
                    } else if (obj.common.unit === '%') {
                        obj.common.min = 0;
                        obj.common.max = 100;

                        // Detect if temperature exists
                        var found = false;
                        for (var k = 0; k < localObjects.length; k++) {
                            if (localObjects[k].common.unit === '°C' || localObjects[k].common.unit === '°F') {
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            obj.common.role = 'value.humidity';
                        }
                    }
                    if (attr.name === 'latitude') {
                        obj.common.role = 'value.gps.latitude';
                    } else if (attr.name === 'longitude') {
                        obj.common.role = 'value.gps.longitude';
                    } if (attr.name === 'gps') {
                        obj.common.role = 'value.gps';
                    }
                } else {
                    if (attr.name === 'battery') {
                        obj.common.role = 'indicator.battery';
                        obj.native.mapping = {'ok': false, 'low': true};
                        obj.common.type = 'boolean';
                        obj.common.states = {false: 'ok', true: 'low'};
                        attr.value = (attr.value !== 'ok');
                    }
                }

                if (attr.enum && !obj.common.states) {
                    obj.common.states = {};
                    for (var e = 0; e < attr.enum.length; e++) {
                        if (attr.enum[e] === 'manu') {
                            obj.common.states.manu = 'manual';
                        } else if (attr.enum[e] === 'auto') {
                            obj.common.states.auto = 'automatic';
                        } else{
                            obj.common.states[attr.enum[e]] = attr.enum[e];
                        }
                    }
                }
                objs.push(obj);
                localObjects.push(obj);
            }
        }

        var actions = device.actions;
        if ((!actions || !actions.length) && device.config) actions = device.config.actions;

        if (actions && actions.length) {
            for (var c = 0; c < actions.length; c++) {
                var action = actions[c];

                for (var p in action.params) {
                    if (!action.params.hasOwnProperty(p)) continue;
                    // try to find state for that
                    var _found = false;
                    for (var u = 0; u < localObjects.length; u++) {
                        if (localObjects[u].native.name === p) {
                            _found = true;
                            obj = localObjects[u];
                            obj.native.control = {
                                action: action.name,
                                deviceId: device.id
                            };
                            obj.common.write = true;
                            if (obj.common.role === 'value.temperature') obj.common.role = 'level.temperature';
                        }
                    }

                    if (!_found) {
                        obj = {
                            _id: adapter.namespace + '.devices.' + device.id + '.' + action.name.replace(/\s/g, '_') + '.' + p.replace(/\s/g, '_'),
                            common: {
                                desc: action.params[p].description || action.description,
                                name: device.name + ' - ' + action.name + '.' + p,
                                read: false,
                                write: true,
                                type: action.params[p].type
                            },
                            native: {
                                name: p,
                                control: {
                                    action: action.name,
                                    deviceId: device.id
                                }
                            },
                            type: 'state'
                        };
                        objs.push(obj);
                    }
                }
            }
        }
    }
    var ids = [];
    for (var j = 0; j < objs.length; j++) {
        ids.push(objs[j]._id);
        objects[objs[j]._id] = objs[j];
    }
    syncObjects(objs, function () {
        syncStates(_states, function () {
            callback && callback(ids);
        });
    });
}

function syncGroups(groups, ids, callback) {
    var enums = [];
    var obj = {
        _id: 'enum.openhab',
        common: {
            members: [],
            name: 'openhab groups'
        },
        native: {},
        type: 'enum'

    };

    enums.push(obj);

    for (var g = 0; g < groups.length; g++) {
        obj = {
            _id: 'enum.openhab.' + groups[g].id,
            type: 'enum',
            common: {
                name: groups[g].name,
                members: []
            },
            native: {}
        };
        for (var m = 0; m < groups[g].devices.length; m++) {
            var id = adapter.namespace + '.devices.' + groups[g].devices[m].replace(/\s/g, '_');
            if (ids.indexOf(id) === -1) {
                // try to find
                var found = false;
                var _id = id.toLowerCase();
                for (var i = 0; i < ids.length; i++) {
                    if (ids[i].toLowerCase() === _id) {
                        id = ids[i];
                        found = true;
                        break;
                    }
                }
                if (found) {
                    obj.common.members.push(id);
                } else {
                    adapter.log.warn('Device "' + groups[g].devices[m] + '" was found in the group "' + groups[g].name + '", but not found in devices');
                }
            } else {
                obj.common.members.push(id);
            }
        }
        enums.push(obj);
    }
    syncObjects(enums, callback);
}
*/
function connect(callback) {
    connectingTimeout = null;
    var auth;
    if (adapter.config.username) {
        auth = {
            auth: {
                user: adapter.config.username,
                pass: adapter.config.password,
                sendImmediately: false
            }
        };
    }

    request.get(URL + '/items?recursive=false', auth, function (err, resp, body) {
        if (body) {
            updateConnected(true);
            try {
                var items = JSON.parse(body);
                var enums = {};
                var _states = [];
                var objs = [];
                var id;
                for (var i = 0; i < items.length; i++) {
                    if (items[i].type === 'Group') {
                        var groupId = 'enum.openhab.' + items[i].name;

                        if ((items[i].label && rooms.indexOf(items[i].label.toLowerCase()) !== -1) || (items[i].name && rooms.indexOf(items[i].name.toLowerCase()) !== -1)) {
                            groupId = 'enum.rooms.' + items[i].name;
                        } else
                        if ((items[i].label && funcs.indexOf(items[i].label.toLowerCase()) !== -1) || (items[i].name && funcs.indexOf(items[i].name.toLowerCase()) !== -1)) {
                            groupId = 'enum.functions.' + items[i].name;
                        }

                        if (enums[items[i].name]) {
                            enums[items[i].name].common.name = items[i].label;
                            enums[items[i].name]._id = groupId;
                        } else {
                            enums[items[i].name] = {
                                _id: groupId,
                                common: {
                                    name: items[i].label,
                                    members: []
                                },
                                native: {

                                },
                                type: 'enum'
                            };
                            objs.push(enums[items[i].name]);
                        }
                    } else {
                        var common = ohTypes[items[i].type] ? ohTypes[items[i].type](items[i]) : {
                            type: 'string',
                            role: 'state',
                            name: items[i].label
                        };
                        id = adapter.namespace + '.items.' + items[i].name;

                        objs.push({
                            _id: id,
                            common: common,
                            native: {
                                name: items[i].name,
                                type: items[i].type
                            },
                            type: 'state'
                        });

                        // insert to enums
                        if (items[i].groupNames && items[i].groupNames.length) {
                            for (var e = 0; e < items[i].groupNames.length; e++) {
                                var group = items[i].groupNames[e];
                                if (!enums[group]) {
                                    enums[group] = {
                                        _id: 'enum.openhab.' + group,
                                        common: {
                                            members: []
                                        },
                                        native: {},
                                        type: 'enum'
                                    };
                                    objs.push(enums[group]);
                                }
                                enums[group].common.members.push(id);
                            }
                        }

                        if (typeof items[i].state !== 'undefined' && items[i].state !== 'undefined') {
                            _states.push({
                                _id: id,
                                val: {val: oh2iob(items[i].type, items[i].state), ack: true}
                            });
                        }
                    }
                }

                syncObjects(objs, function () {
                    syncStates(_states, callback);
                    if (adapter.config.username) {
                        URL = URL.replace(/^http:\/\//, 'http://' + adapter.config.username + ':' + adapter.config.password + '@');
                        URL = URL.replace(/^https:\/\//, 'https://' + adapter.config.username + ':' + adapter.config.password + '@');
                    }

                    es = new EventSource(URL + '/events');

                    es.addEventListener('message', function (eventPayload) {
                        var event = JSON.parse(eventPayload.data);
                        if (event.type === 'ItemStateEvent') {
                            // smarthome/items/GEG_HZ_Soll/state
                            var parts = event.topic.split('/');
                            var topic = parts[2];

                            var value = JSON.parse(event.payload);
                            value.value = oh2iob(value.type, value.value);

                            adapter.log.debug('Received [' + adapter.namespace + '.items.' + topic + '] = ' + JSON.stringify(value));
                            adapter.setState(adapter.namespace + '.items.' + topic, value.value, true);
                        }
                    });

                    es.onerror = function (err) {
                        if (err) {
                            if (err.status === 401 || err.status === 403) {
                                adapter.log.error('not authorized');
                            } else {
                                adapter.log.debug('Error: ' + JSON.stringify(err));
                            }
                        }
                    };
                });
            } catch (e) {
                updateConnected(false);
                adapter.log.error('Invalid answer on "' + URL + '/items?recursive=false": cannot parse response: ' + e);
                connectingTimeout = setTimeout(connect, adapter.config.reconnectTimeout);
                callback && callback();
            }
        } else {
            updateConnected(false);
            adapter.log.error('Cannot get answer from "' + URL + '/items?recursive=false": ' + err);
            connectingTimeout = setTimeout(connect, adapter.config.reconnectTimeout);
            callback && callback();
        }
    });
}

function updateConnected(isConnected) {
    if (connected !== isConnected) {
        connected = isConnected;
        adapter.setState('info.connection', connected, true);
        adapter.log.info(isConnected ? 'connected' : 'disconnected');
        if (!isConnected && es) {
            es.close();
            es = null;
        }
    }
}

function main() {
    if (adapter.config.url) {
        adapter.config.protocol = adapter.config.url.match(/^https:/) ? 'https' : 'http';
        var url = adapter.config.url.replace('https://', '').replace('http://', '');
        var parts = url.split('/');
        adapter.config.path = '/' + (parts[1] || '');
        parts = parts[0].split(':');
        adapter.config.host = parts[0];
        adapter.config.port = parts[1] || 80;
        delete adapter.config.url;
    }

    if (adapter.config.host) {
        URL = adapter.config.protocol + '://' + adapter.config.host + ':' + (adapter.config.port || 80) + adapter.config.path;
        if (URL[URL.length - 1] === '/') {
            URL = URL.substring(0, URL.length - 1);
        }
    } else {
        adapter.log.warn('No REST API URL defined.');
        return;
    }

    adapter.config.reconnectTimeout = parseInt(adapter.config.reconnectTimeout, 10) || 30000;

    adapter.setState('info.connection', false, true);
    connect();
    // in this openhab all states changes inside the adapters namespace are subscribed
    adapter.subscribeStates('*');
}
